# mybatis

## MyBatis是什么？

mybatis是一个半自动持久化框架， 主要是与数据库进行交互。封装了JDBC，以及对象与数据库数据的映射。开发人员只需要关心sql语句即可。

### 优点

sql语句与java代码分离。 一般出问题都是sql语句的问题，方便查找问题

动态sql语句， 支持逻辑拼接sql语句

java对象与数据库字段的映射

因为手写sql，所以可以对sql优化提升性能

### 缺点

需要开发人员来写sql语句

## mybatis与hibernate的区别

### 共同点

都是持久化层框架，与数据库交互

### 不同点

mybatis是半自动框架，需要开发人员写sql，方便优化sql

hibernate是全自动框架，不需要开发人员写sql，不方便优化sql

## jdbc的不足，以及mybatis如何解决

- jdbc需要频繁创建关闭数据库连接， mybatis整合连接池
- jdbc使用时java代码和sql耦合， mybatis将sql语句写在xml中
- jdbc使用时对象解析复杂， mybatis会自动将查询结果映射为java对象，列名不同时三种解决方案如下
  - 开启自动驼峰映射
  - resultMap
  - sql语句写别名
- jdbc拼接sql语句麻烦， mybatis支持动态sql标签

## mybatis的编码流程

- 创建SqlSessionFactory
- 通过SqlSessionFactory创建SqlSession
- 通过sqlsession执行数据库操作
- 调用session.commit()提交事务
- 调用session.close()关闭会话

## mybatis的工作原理

1. 解析mybatis的全局配置文件， 配置了数据库四大参数，连接池等参数
2. 解析每个mapper文件， 解析其中的select，insert，update，delete标签映射为java中的MappedStatement对象（包含了需要执行的sql语句， 以及#{}占位符**（PS:在执行sql语句时需要替换）**，请求响应参数类型等）。以namespace+sql语句的id属性值作为map中的key，mappedStatement对象为value存入到map容器中。
3. 我们只会写mapper接口，并不会写mapper的实现类。当调用mapper接口中的方法时mybatis会动态的帮我们生成一个代理对象。
4. 所以我们最终调用的其实是代理类中的逻辑（从map中获取mappedstatement对象，得到sql语句封装jdbc执行）。
5. 代理对象将获取到的结果映射为java中的对象

### #{}和${}的区别

#{}是占位符，预编译处理；${}是拼接符，字符串替换，没有预编译处理。

Mybatis在处理#{}时，会将SQL中的#{}替换为?号，调用PreparedStatement的set方法来赋值。

## 模糊查询like语句该怎么写

- ’%${question}%’ 可能引起SQL注入，不推荐
- "%"#{question}"%" 
- **CONCAT(’%’,#{question},’%’) 使用CONCAT()函数，（推荐）**

## 在mapper中如何传递多个参数

- **顺序传参法**，在xml写sql语句时#{0}，#{1}获取参数。 不推荐
- **@Param注解传参法**，推荐
- **Map传参法**，推荐
- **Java Bean传参法**，推荐

## Mybatis如何执行批量操作

- **使用foreach标签**

```xml
foreach标签的属性主要有item(每次遍历的元素)，index（每次遍历的索引），collection（需要遍历的集合），open（以什么开头），separator（以什么分割），close（以什么结束）。

int addEmpsBatch(@Param("emps") List<Employee> emps);

<insert id="addEmpsBatch">
    INSERT INTO emp(ename,gender,email,did)
    VALUES
    <foreach collection="emps" item="emp" separator=",">
        (#{emp.eName},#{emp.gender},#{emp.email},#{emp.dept.id})
    </foreach>
</insert>

<insert id="addEmpsBatch">
    <foreach collection="emps" item="emp" separator=";">                                 
        INSERT INTO emp(ename,gender,email,did)
        VALUES(#{emp.eName},#{emp.gender},#{emp.email},#{emp.dept.id})
    </foreach>
</insert>
```

- java代码中循环单笔插入

  ```java
  for (Student stu: studentList) {
  	studentMapper.insert(stu);
  }
  ```

## 如何获取生成的主键

useGeneratedKeys="true" keyProperty="id" 

## 什么是MyBatis的接口绑定？有哪些实现方式？

任意定义接口，然后把接口里面的方法和SQL语句绑定，直接调用接口方法就可以。

- 注解， 接口方法上加上@Select， @Update, @Delete, @Insert。 注解参数中写sql语句
- 在xml文件中写sql语句。 推荐

## 这个Mapper接口的工作原理是什么？Mapper接口里的方法，参数不同时，方法能重载吗

Mapper接口的工作原理是JDK动态代理，Mybatis运行时会使用JDK动态代理为Mapper接口生成代理proxy对象，代理对象proxy会拦截接口方法，转而执行MappedStatement所代表的sql，然后将sql执行结果返回。



不可以， 因为xml中namespace与接口全限定名相同。 xml中sql语句的id与方法名相同。 namespace+id作为map中的key，重复会被覆盖掉。

## Mybatis不同的Xml映射文件，id是否可以重复？

不同的xml文件id是可以重复的， 因为namespace+id作为map中的key。 而不同的xml文件namespace不同，id自然无所谓

## Mybatis是如何将sql执行结果封装为目标对象并返回的？都有哪些映射形式？

- 使用resultMap
- 使用别名
- 使用resultType（只能映射数据库列名与java字段名相同的属性）

## Xml映射文件中，除了常见的select|insert|updae|delete标签之外，还有哪些标签？

动态sql让我们在Xml映射文件内，以标签的形式编写动态sql，完成逻辑判断和动态拼接sql的功能

- resultMap， 响应参数映射

- parameterMap， 请求参数映射

- sql， sql片段

  ```xml
  <sql id="test">id, name, age, address</sql>
  ```

- include， 引用sql片段

```xml
<select id="queryUser">select <include refid="test"></include></select>
```

- trim,set,choose,when,otherwise,bind不常用
- where   
- if
- foreach
  - item(每次遍历的元素)
  - index（每次遍历的索引）
  - collection（需要遍历的集合）
  - open（以什么开头）
  - separator（以什么分割）
  - close（以什么结束）。



## 你们项目中是如何进行分页的？分页插件的原理是什么？

项目中使用的是PageHelper插件来实现的分页



分页插件的基本原理是使用Mybatis提供的插件接口，实现自定义插件，在插件的拦截方法内拦截待执行的sql，然后重写sql，根据dialect方言，添加对应的物理分页语句和物理分页参数。

举例：select * from student，拦截sql后重写为：select t.* from (select * from student) t limit 0, 10

