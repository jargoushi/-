# 线程

## 什么是进程， 什么是线程

进程就是一个应用程序， 比如QQ，微信，IDEA, 浏览器。

线程是进程中的一个执行单元，一个进程执行过程中会开辟出多个线程。线程也称为轻量级进程

## 线程的优缺点

### 优点

利用计算机多CPU多核同时处理多件事（1个CPU同时只能执行一件事），合理的利用线程可以提升性能

### 缺点

线程使用不当会降低性能（PS： 线程与线程之前的切换需要耗费时间，所以如果线程过多不一定快）

多个线程对共享资源访问时，需要考虑线程安全的问题

## 守护线程与非守护线程

- 守护线程是为非守护线程服务。 必须线程执行之前调用Thread.setDaemon(true);可以设置为守护线程
- jvm虚拟机会等待非守护线程，但是不会等待守护线程

比如： java应用启动时最少会开辟两个线程，一个是main线程，一个是垃圾回收线程。垃圾回收线程是为main线程服务的。当main线程执行完毕不再生成垃圾时，垃圾回收线程也就没有了存在的必要。

main线程就是用户（守护）线程， 垃圾回收线程就是非守护线程

## 线程的上下文切换

多线程会共同使用一组计算机上的 CPU ，而线程数大于给程序分配的 CPU 数量时，为了让各个线程都有执行的机会，就需要轮转使用 CPU 。 不同线程之前的切换就是上下文切换



比如计算机只有1个CPU， 但是可以开辟多个进程以及多个线程（QQ, 微信，浏览器）。我们看到的情况是多个进程同时在执行，其实同时只能有一个进程线程在执行。 是因为多个线程会抢夺CPU的时间片，获取到时间片就执行，时间片执行完毕后其他线程会再次抢夺CPU的时间片就是上下文切换



## 线程调度算法

- **抢占式调度模型（默认）**。 多个线程抢夺CPU的时间片，抢夺到就执行，否则等待
- 分时调度模型。 CPU为每个线程分配平均的时间片，执行完毕后执行下一个线程

## 线程饥饿

一个或者多个线程因为种种原因无法获得所需要的资源，导致一直无法执行的状态

- CPU的时间片永远被高优先级的线程抢夺到，低优先级的线程无法执行到
- 线程在同步代码块（synchronized）外永远处于等待状态，没有机会执行

## **线程优先级的理解**

 每一个线程都有一个优先级，共1（最小）-10（最大）个优先级值,默认的优先级为5

理论上来说高优先级的线程会优于低优先级的线程执行。但是要依赖于操作系统，不一定是这样的，有可能低优先级的比高优先级的先执行。   

## 线程的声明周期

- 新建 :   当new一个线程对象，该线程就进入了新建状态
- 就绪：当调用了线程的start方法， 该线程就进入了就绪状态
- 运行： 当获取到CPU分配的时间片， 该线程就进入了运行状态
- 阻塞：由于某些原因导致正在执行的线程让出CPU的执行权
  - sleep(5000) : 睡眠5秒
  - wait():           等待
- 死亡：  当线程代码体（run方法）执行完毕，或者执行过程中出现异常

![线程的生命周期](D:\课件\-\线程的生命周期.png)

## 创建线程的三种方式

- 继承Thread类（继承了Thread类无法继承其他的类）
- 实现Runnable接口
- 实现Callable接口

## 什么叫线程安全

指某个函数、函数库在多线程环境中被调用时，能够正确地处理多个线程之间的共享变量，使程序功能正确完成。

servlet,springmvc(如果是单例的作用域）不是线程安全的

struts2，springmvc（如果是多例的作用域）是线程安全的



## 单例设计模式

某个类的实例在多线程环境下只会被创建一次出来

- 懒汉式单例
- 饿汉式单例
- 枚举

## Java Timer 类

`java.util.Timer` ，是一个工具类，可以用于安排一个线程在未来的某个特定时间执行。Timer 类可以用安排一次性任务或者周期任务。

`java.util.TimerTask` ，是一个实现了 Runnable 接口的抽象类，我们需要去继承这个类来创建我们自己的定时任务并使用 Timer 去安排它的执行。

### 缺点：

- 如果执行定时任务的过程中出现了异常则定时任务就结束了，后续的定时任务也不会再触发
- 